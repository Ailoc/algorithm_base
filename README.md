ğŸ“‹è¿™æ˜¯ä¸€ä¸ªè®°å½•è‡ªå·±å¶å°”ç®—æ³•ç»ƒä¹ çš„ä»£ç ä»“åº“ï¼Œæœ‰æ—¶é—´ç»ƒä¸€ç»ƒï¼Œå¼€å‘ä¸€ä¸‹å¤§è„‘
# ğŸ§  LeetCode Algorithm Notes

æœ¬é¡¹ç›®ç”¨äºæ•´ç†å’Œè®°å½•æˆ‘çš„ LeetCode åˆ·é¢˜ä»£ç ä¸æ€è·¯ï¼ŒæŒ‰ç…§**æ•°æ®ç»“æ„**ä¸**ç®—æ³•ç±»å‹**åˆ†ç±»å±•ç¤ºã€‚  
ç‚¹å‡»è¡¨æ ¼ä¸­çš„é¢˜ç›®å¯ä»¥ç›´æ¥è·³è½¬åˆ°è¯¥é¢˜çš„è¯¦ç»†ä»£ç å®ç°ã€‚

1ï¸âƒ£ 2ï¸âƒ£ 3ï¸âƒ£ 4ï¸âƒ£ 5ï¸âƒ£ 6ï¸âƒ£ 7ï¸âƒ£ 8ï¸âƒ£ 9ï¸âƒ£ ğŸ”Ÿ
---

## 
## ğŸ“˜ æ•°ç»„ (Array)

| #    | é¢˜ç›®                                                         | ç±»å‹     | LeetCode                                                     | éš¾åº¦   |
| ---- | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | ------ |
| 1    | [ä¸¤æ•°ä¹‹å’Œ](#1ï¸âƒ£-ä¸¤æ•°ä¹‹å’Œ)                      | å“ˆå¸Œè¡¨   | [1. ä¸¤æ•°ä¹‹å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/two-sum/)        | ğŸŸ¢ Easy |
| 2    | [æœ€é•¿å…¬å…±å‰ç¼€](#2ï¸âƒ£-æœ€é•¿å…¬å…±å‰ç¼€) | åŠ¨æ€è§„åˆ’ | [14. æœ€é•¿å…¬å…±å‰ç¼€ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/longest-common-prefix/) | ğŸŸ¢ Easy |

## 
## ğŸ”— é“¾è¡¨ (LinkedList)
| #    | é¢˜ç›®                                                         | ç±»å‹     | LeetCode                                                     | éš¾åº¦   |
| ---- | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | ------ |
| 1    | [åè½¬é“¾è¡¨](#1ï¸âƒ£-åè½¬é“¾è¡¨)                      | é“¾è¡¨   | [206. åè½¬é“¾è¡¨ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/reverse-linked-list/description/?envType=problem-list-v2&envId=linked-list)        | ğŸŸ¢ Easy |
| 2    | [ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹](#2ï¸âƒ£-ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹)                      | é“¾è¡¨   | [24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/swap-nodes-in-pairs/description/?envType=problem-list-v2&envId=linked-list)        | ğŸŸ¢ Easy |
| 3    | [ç¯å½¢é“¾è¡¨](#3ï¸âƒ£-ç¯å½¢é“¾è¡¨)                      | é“¾è¡¨   | [141. ç¯å½¢é“¾è¡¨ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/linked-list-cycle/description/?envType=problem-list-v2&envId=linked-list)        | ğŸŸ¢ Easy |
| 4    | [ç¯å½¢é“¾è¡¨-æ‰¾å…¥ç¯ç‚¹](#4ï¸âƒ£-ç¯å½¢é“¾è¡¨-æ‰¾å…¥ç¯ç‚¹)                      | é“¾è¡¨   | [142. ç¯å½¢é“¾è¡¨ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/linked-list-cycle-ii/solutions/441131/huan-xing-lian-biao-ii-by-leetcode-solution/?envType=problem-list-v2&envId=linked-list)- æ‰¾å…¥ç¯ç‚¹        | ğŸŸ¢ Easy |
| 5    | [Kä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨](#5ï¸âƒ£-Kä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨)                      | é“¾è¡¨   | [25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/reverse-nodes-in-k-group/?envType=problem-list-v2&envId=linked-list)        | ğŸŸ¢ Easy |

## 
## ğŸ§± æ ˆå’Œé˜Ÿåˆ— (Stack & Queue)

| #    | é¢˜ç›®                                                         | ç±»å‹     | LeetCode                                                     | éš¾åº¦   |
| ---- | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | ------ |
| 1    | [æœ‰æ•ˆçš„æ‹¬å·](#1ï¸âƒ£-æœ‰æ•ˆçš„æ‹¬å·)                      | æ ˆ   | [20. æœ‰æ•ˆçš„æ‹¬å· - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/valid-parentheses/description/?envType=problem-list-v2&envId=stack)         | ğŸŸ¢ Easy |
| 2    | [ç”¨æ ˆå®ç°é˜Ÿåˆ—](#2ï¸âƒ£-ç”¨æ ˆå®ç°é˜Ÿåˆ—) | æ ˆ | [232. ç”¨æ ˆå®ç°é˜Ÿåˆ— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/implement-queue-using-stacks/?envType=problem-list-v2&envId=stack) | ğŸŸ¢ Easy |
| 3    | [ç”¨é˜Ÿåˆ—å®ç°æ ˆ](#3ï¸âƒ£-ç”¨é˜Ÿåˆ—å®ç°æ ˆ) | æ ˆ | [225. ç”¨é˜Ÿåˆ—å®ç°æ ˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/implement-stack-using-queues/description/?envType=problem-list-v2&envId=stack) | ğŸŸ¢ Easy |

## 
## ğŸ§® ä¼˜å…ˆé˜Ÿåˆ— (Priority Queue)

| #    | é¢˜ç›®                                                         | ç±»å‹     | LeetCode                                                     | éš¾åº¦   |
| ---- | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | ------ |
| 1    | [æ•°æ®æµä¸­çš„ç¬¬Kå¤§å…ƒç´ ](#1ï¸âƒ£-æ•°æ®æµä¸­çš„ç¬¬Kå¤§å…ƒç´ )                      | å †   | [703. æ•°æ®æµä¸­çš„ç¬¬ K å¤§å…ƒç´  - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/kth-largest-element-in-a-stream/description/)        | ğŸŸ¢ Easy |
| 2    | [æ»‘åŠ¨çª—å£æœ€å¤§å€¼](#2ï¸âƒ£-æ»‘åŠ¨çª—å£æœ€å¤§å€¼)                      | é˜Ÿåˆ—   | [239. æ»‘åŠ¨çª—å£æœ€å¤§å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/sliding-window-maximum/description/)        | ğŸŸ¢ Easy |
| 3    | [æ—©é¤ç»„åˆ](#3ï¸âƒ£-æ—©é¤ç»„åˆ)                      | é˜Ÿåˆ—   | [LCP 18. æ—©é¤ç»„åˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/2vYnGI/description/)        | ğŸŸ¢ Easy |

## 
## ğŸŒ³ äºŒå‰æ ‘ (Binary Tree)

| #    | é¢˜ç›®                                                         | ç±»å‹     | LeetCode                                                     | éš¾åº¦   |
| ---- | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | ------ |
| 1    | [ç›¸åŒçš„æ ‘](#1ï¸âƒ£-ç›¸åŒçš„æ ‘)                      | äºŒå‰æ ‘   | [100. ç›¸åŒçš„æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/same-tree/)       | ğŸŸ¢ Easy |

## 
## ğŸ”¢ å“ˆå¸Œè¡¨ä¸é›†åˆ (Map & Set)

| #    | é¢˜ç›®                                                         | ç±»å‹     | LeetCode                                                     | éš¾åº¦   |
| ---- | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | ------ |
| 1    | [æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯](#1ï¸âƒ£-æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯)                      | äºŒå‰æ ‘   | [242. æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/valid-anagram/description/)      | ğŸŸ¢ Easy |

---
### 1ï¸âƒ£ ä¸¤æ•°ä¹‹å’Œ

```go
func twoSum(nums []int, target int) []int {
    m := map[int]int{}
    for index1, v1 := range nums {
        if index2, ok := m[target - v1]; !ok {
            m[v1] = index1
        } else {
            return []int{index2, index1}
        }
    }
    return nil
}
```

---
### 2ï¸âƒ£ æœ€é•¿å…¬å…±å‰ç¼€

```go
func longestCommonPrefix(strs []string) string {
    u := []rune{}
    flag := true
    for index, c := range strs[0] { 
        for i := 1; i < len(strs) && flag == true; i++ {
            if index < len(strs[i]) && rune(strs[i][index]) == c {
                flag = true
            } else {
                flag = false
                break
            }
        }
        if flag == true {
            u = append(u, c)
        }
    }
    return string(u)
}
```

---

### 1ï¸âƒ£ åè½¬é“¾è¡¨ <a id="åè½¬é“¾è¡¨"></a>

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode {
    prev := (*ListNode)(nil)
    cur := head
    for cur != nil {
        head = head.Next
        cur.Next = prev
        prev = cur
        cur = head
    }
    return prev
}
```

---

### 2ï¸âƒ£ ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹<a id="ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹"></a>

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func swapPairs(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    prevHead := &ListNode{0, head}
    cur, swapNode := head, head.Next
    rt := swapNode
    for {
        prevHead.Next = swapNode
        cur.Next = swapNode.Next
        swapNode.Next = cur
        prevHead = cur
        if cur.Next != nil && cur.Next.Next != nil {
            cur = cur.Next
            swapNode = cur.Next
        }else {
            break
        }
    }
    return rt
}
```

---
### 3ï¸âƒ£ ç¯å½¢é“¾è¡¨<a id="ç¯å½¢é“¾è¡¨"></a>

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func hasCycle(head *ListNode) bool {
    // fast, slow := head, head
    // for slow != nil && fast != nil && fast.Next != nil {
    //     slow = slow.Next
    //     fast = fast.Next.Next
    //     if slow == fast {
    //         return true
    //     }
    // }
    // return false

    m := map[*ListNode]struct{}{}
    cur := head
    for cur != nil {
        if _, ok := m[cur]; ok {
            return true
        }else {
            m[cur] = struct{}{}
        }
        cur = cur.Next
    }
    return false
}
```

---
### 4ï¸âƒ£ ç¯å½¢é“¾è¡¨-æ‰¾å…¥ç¯ç‚¹<a id="ç¯å½¢é“¾è¡¨-æ‰¾å…¥ç¯ç‚¹"></a>

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func detectCycle(head *ListNode) *ListNode {
    // m := map[*ListNode]struct{}{}
    // for head != nil {
    //     if _, ok := m[head]; ok {
    //         return head
    //     }
    //     m[head] = struct{}{}
    //     head = head.Next
    // }
    // return nil

    fast, slow := head, head
    for fast != nil && fast.Next != nil{
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            fast = head
            for slow != fast {
                fast = fast.Next
                slow = slow.Next
            }
            return slow
        }
    }
    return nil
}
```

---
### 5ï¸âƒ£ Kä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨<a id="Kä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨"></a>

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseKGroup(head *ListNode, k int) *ListNode {
    if head == nil || head.Next == nil || k == 1 {
        return head
    }
    dummy := &ListNode{0, head}
    prevGroup := dummy
    for head != nil {
        curr := head
        count := 0
        for curr != nil && count < k {
            count++
            curr = curr.Next
        }
        if count < k {
            break
        }
        curr = head
        var prev *ListNode
        for i := 0; i < k; i++ {
            next := curr.Next
            curr.Next = prev
            prev = curr
            curr = next
        }
        prevGroup.Next = prev
        head.Next = curr
        prevGroup = head
        head = curr
    }
    return dummy.Next
}
```

---

### 1ï¸âƒ£ æœ‰æ•ˆçš„æ‹¬å·

```go
func isValid(s string) bool {
    stack := []rune{}
    for _, ch := range s{
        switch ch {
        case '(', '{', '[':
            stack = append(stack, ch)
        case ')', '}', ']':
            if len(stack) > 0 {
                if (ch == ')' && stack[len(stack)-1] == '(') ||
                (ch == '}' && stack[len(stack)-1] == '{') ||
                (ch == ']' && stack[len(stack)-1] == '[') {
                    stack = stack[:len(stack)-1]
                }else {
                    return false
                }
            }else {
                return false
            }
        }
    }
    return len(stack) == 0
}
```

---
### 2ï¸âƒ£ ç”¨æ ˆå®ç°é˜Ÿåˆ—

```go
type MyQueue struct {
    stack1 []int
    stack2 []int
}


func Constructor() MyQueue {
    return MyQueue{}
}


func (this *MyQueue) Push(x int)  {
    for len(this.stack2) > 0 {
        this.stack1 = append(this.stack1, this.stack2[len(this.stack2)-1])
        this.stack2 = this.stack2[:len(this.stack2)-1]
    }
    this.stack1 = append(this.stack1, x)
}


func (this *MyQueue) Pop() int {
    if len(this.stack2) > 0 {
        res := this.stack2[len(this.stack2)-1]
        this.stack2 = this.stack2[:len(this.stack2)-1]
        return res
    }
    for len(this.stack1) > 0 {
        this.stack2 = append(this.stack2, this.stack1[len(this.stack1)-1])
        this.stack1 = this.stack1[:len(this.stack1)-1]
    }
    res := this.stack2[len(this.stack2)-1]
    this.stack2 = this.stack2[:len(this.stack2)-1]
    return res
}


func (this *MyQueue) Peek() int {
    if len(this.stack2) > 0 {
        return this.stack2[len(this.stack2)-1]
    }
    for len(this.stack1) > 0 {
        this.stack2 = append(this.stack2, this.stack1[len(this.stack1)-1])
        this.stack1 = this.stack1[:len(this.stack1)-1]
    }
    return this.stack2[len(this.stack2)-1]
}


func (this *MyQueue) Empty() bool {
    return len(this.stack1) == 0 && len(this.stack2) == 0
}


/**
 * Your MyQueue object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(x);
 * param_2 := obj.Pop();
 * param_3 := obj.Peek();
 * param_4 := obj.Empty();
 */
```

---
### 3ï¸âƒ£ ç”¨é˜Ÿåˆ—å®ç°æ ˆ

```go
type MyStack struct {
    queue1 []int
    queue2 []int
}


func Constructor() MyStack {
    return MyStack{}
}


func (this *MyStack) Push(x int)  {
    if len(this.queue2) > 0 {
        this.queue2 = append(this.queue2, x)
        return
    }
    this.queue1 = append(this.queue1, x)
}


func (this *MyStack) Pop() int {
    res := 0
    if len(this.queue1) > 0 {
        for len(this.queue1) > 1 {
            this.queue2 = append(this.queue2, this.queue1[0])
            this.queue1 = this.queue1[1:]
        }
        res = this.queue1[0]
        this.queue1 = this.queue1[0:0]
    } else {
        for len(this.queue2) > 1 {
            this.queue1 = append(this.queue1, this.queue2[0])
            this.queue2 = this.queue2[1:]
        }
        res = this.queue2[0]
        this.queue2 = this.queue2[0:0]
    }
    return res
}


func (this *MyStack) Top() int {
    res := 0
    if len(this.queue1) > 0 {
        for len(this.queue1) > 1 {
            this.queue2 = append(this.queue2, this.queue1[0])
            this.queue1 = this.queue1[1:]
        }
        res = this.queue1[0]
        this.queue1 = this.queue1[0:0]
        this.queue2 =  append(this.queue2, res)
    } else {
        for len(this.queue2) > 1 {
            this.queue1 = append(this.queue1, this.queue2[0])
            this.queue2 = this.queue2[1:]
        }
        res = this.queue2[0]
        this.queue2 = this.queue2[0:0]
        this.queue1 =  append(this.queue1, res)
    }
    return res
}


func (this *MyStack) Empty() bool {
    return len(this.queue1) == 0 && len(this.queue2) == 0
}


/**
 * Your MyStack object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(x);
 * param_2 := obj.Pop();
 * param_3 := obj.Top();
 * param_4 := obj.Empty();
 */
```

---

### 1ï¸âƒ£ æ•°æ®æµä¸­çš„ç¬¬Kå¤§å…ƒç´ 

```go
type KthLargest struct {
    u sort.IntSlice
    k int
}


func Constructor(k int, nums []int) KthLargest {
    kl := KthLargest{
        u: sort.IntSlice(nums),
        k: k,
    }
    sort.Sort(sort.Reverse(kl.u))
    return kl
}


func (this *KthLargest) Add(val int) int {
    if len(this.u) >= this.k && this.u[this.k-1] >= val {
        return this.u[this.k-1]
    }
    this.u = append(this.u, val)
    sort.Sort(sort.Reverse(this.u))
    this.u = this.u[:this.k]
    return this.u[this.k-1]
}


/**
 * Your KthLargest object will be instantiated and called as such:
 * obj := Constructor(k, nums);
 * param_1 := obj.Add(val);
 */
```

---
### 2ï¸âƒ£ æ»‘åŠ¨çª—å£æœ€å¤§å€¼

```go
func maxSlidingWindow(nums []int, k int) []int {
    if len(nums) == 0 || k <= 0 || k > len(nums) {
        return []int{}
    }
    if k == 1 {
        return nums
    }
    
    // ä½¿ç”¨åŒç«¯é˜Ÿåˆ—å­˜å‚¨ç´¢å¼•
    deque := make([]int, 0, k)
    // é¢„åˆ†é…ç»“æœåˆ‡ç‰‡å®¹é‡
    res := make([]int, 0, len(nums)-k+1)
    
    for i := 0; i < len(nums); i++ {
        // ç§»é™¤çª—å£å¤–çš„ç´¢å¼•
        if len(deque) > 0 && deque[0] <= i-k {
            deque = deque[1:]
        }
        // ç§»é™¤é˜Ÿåˆ—å°¾éƒ¨å°äºå½“å‰å…ƒç´ çš„ç´¢å¼•ï¼Œä¿æŒå•è°ƒé€’å‡
        for len(deque) > 0 && nums[deque[len(deque)-1]] < nums[i] {
            deque = deque[:len(deque)-1]
        }
        // æ·»åŠ å½“å‰ç´¢å¼•
        deque = append(deque, i)
        // çª—å£å½¢æˆåè®°å½•æœ€å¤§å€¼
        if i >= k-1 {
            res = append(res, nums[deque[0]])
        }
    }
    return res
}
```

---
### 3ï¸âƒ£ æ—©é¤ç»„åˆ

```go
func breakfastNumber(staple []int, drinks []int, x int) int {
    num := 0
    sort.Ints(staple)
    sort.Ints(drinks)
    for _, s := range staple {
        target := x - s 
        low := 0
        high := len(drinks)-1
        for low <= high {
            mid := (low + high) / 2
            if drinks[mid] > target {
                high = mid - 1
            }else {
                low = mid + 1
            }
        }
        num += low
    }
    return num % 1000000007
}
```

---

### 1ï¸âƒ£ ç›¸åŒçš„æ ‘

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func isSameTree(p *TreeNode, q *TreeNode) bool {
    if p == nil && q == nil{return true}
    if (p == nil && q != nil) || (p != nil && q == nil) || p.Val != q.Val {return false}
    if p.Val == q.Val {
        return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)
    }
    return false
}
```

---

### 1ï¸âƒ£ æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯

```go
func isAnagram(s string, t string) bool {
    if len(s) != len(t) {return false}
    u := map[rune]int{}
    for i := 0; i < len(s); i++ {
        if _, ok := u[rune(s[i])]; ok {
            u[rune(s[i])]++
        } else {
            u[rune(s[i])] = 1
        }
        if _, ok := u[rune(t[i])]; ok {
            u[rune(t[i])]--
        } else {
            u[rune(t[i])] = -1
        }
    }
    for _, v := range u {
        if v != 0 {return false}
    }
    return true
}
```

---
