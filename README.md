📋这是一个记录自己偶尔算法练习的代码仓库，有时间练一练，开发一下大脑
# 🧠 LeetCode Algorithm Notes

本项目用于整理和记录我的 LeetCode 刷题代码与思路，按照**数据结构**与**算法类型**分类展示。  
点击表格中的题目可以直接跳转到该题的详细代码实现。

1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 6️⃣ 7️⃣ 8️⃣ 9️⃣ 🔟
---

## 
## 📘 数组 (Array)

| #    | 题目                                                         | 类型     | LeetCode                                                     | 难度   |
| ---- | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | ------ |
| 1    | [两数之和](#1️⃣-两数之和)                      | 哈希表   | [1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/)        | 🟢 Easy |
| 2    | [最长公共前缀](#2️⃣-最长公共前缀) | 动态规划 | [14. 最长公共前缀 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-common-prefix/) | 🟢 Easy |

## 
## 🔗 链表 (LinkedList)
| #    | 题目                                                         | 类型     | LeetCode                                                     | 难度   |
| ---- | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | ------ |
| 1    | [反转链表](#1️⃣-反转链表)                      | 链表   | [206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/description/?envType=problem-list-v2&envId=linked-list)        | 🟢 Easy |
| 2    | [两两交换链表中的节点](#2️⃣-两两交换链表中的节点)                      | 链表   | [24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/description/?envType=problem-list-v2&envId=linked-list)        | 🟢 Easy |
| 3    | [环形链表](#3️⃣-环形链表)                      | 链表   | [141. 环形链表 - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle/description/?envType=problem-list-v2&envId=linked-list)        | 🟢 Easy |
| 4    | [环形链表-找入环点](#4️⃣-环形链表-找入环点)                      | 链表   | [142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/solutions/441131/huan-xing-lian-biao-ii-by-leetcode-solution/?envType=problem-list-v2&envId=linked-list)- 找入环点        | 🟢 Easy |
| 5    | [K个一组翻转链表](#5️⃣-K个一组翻转链表)                      | 链表   | [25. K 个一组翻转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-nodes-in-k-group/?envType=problem-list-v2&envId=linked-list)        | 🟢 Easy |

## 
## 🧱 栈和队列 (Stack & Queue)

| #    | 题目                                                         | 类型     | LeetCode                                                     | 难度   |
| ---- | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | ------ |
| 1    | [有效的括号](#1️⃣-有效的括号)                      | 栈   | [20. 有效的括号 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parentheses/description/?envType=problem-list-v2&envId=stack)         | 🟢 Easy |
| 2    | [用栈实现队列](#2️⃣-用栈实现队列) | 栈 | [232. 用栈实现队列 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-queue-using-stacks/?envType=problem-list-v2&envId=stack) | 🟢 Easy |
| 3    | [用队列实现栈](#3️⃣-用队列实现栈) | 栈 | [225. 用队列实现栈 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-stack-using-queues/description/?envType=problem-list-v2&envId=stack) | 🟢 Easy |

## 
## 🧮 优先队列 (Priority Queue)

| #    | 题目                                                         | 类型     | LeetCode                                                     | 难度   |
| ---- | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | ------ |
| 1    | [数据流中的第K大元素](#1️⃣-数据流中的第K大元素)                      | 堆   | [703. 数据流中的第 K 大元素 - 力扣（LeetCode）](https://leetcode.cn/problems/kth-largest-element-in-a-stream/description/)        | 🟢 Easy |
| 2    | [滑动窗口最大值](#2️⃣-滑动窗口最大值)                      | 队列   | [239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/description/)        | 🟢 Easy |
| 3    | [早餐组合](#3️⃣-早餐组合)                      | 队列   | [LCP 18. 早餐组合 - 力扣（LeetCode）](https://leetcode.cn/problems/2vYnGI/description/)        | 🟢 Easy |

## 
## 🌳 二叉树 (Binary Tree)

| #    | 题目                                                         | 类型     | LeetCode                                                     | 难度   |
| ---- | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | ------ |
| 1    | [相同的树](#1️⃣-相同的树)                      | 二叉树   | [100. 相同的树 - 力扣（LeetCode）](https://leetcode.cn/problems/same-tree/)       | 🟢 Easy |

## 
## 🔢 哈希表与集合 (Map & Set)

| #    | 题目                                                         | 类型     | LeetCode                                                     | 难度   |
| ---- | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | ------ |
| 1    | [有效的字母异位词](#1️⃣-有效的字母异位词)                      | 二叉树   | [242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-anagram/description/)      | 🟢 Easy |

---
### 1️⃣ 两数之和

```go
func twoSum(nums []int, target int) []int {
    m := map[int]int{}
    for index1, v1 := range nums {
        if index2, ok := m[target - v1]; !ok {
            m[v1] = index1
        } else {
            return []int{index2, index1}
        }
    }
    return nil
}
```

---
### 2️⃣ 最长公共前缀

```go
func longestCommonPrefix(strs []string) string {
    u := []rune{}
    flag := true
    for index, c := range strs[0] { 
        for i := 1; i < len(strs) && flag == true; i++ {
            if index < len(strs[i]) && rune(strs[i][index]) == c {
                flag = true
            } else {
                flag = false
                break
            }
        }
        if flag == true {
            u = append(u, c)
        }
    }
    return string(u)
}
```

---

### 1️⃣ 反转链表 <a id="反转链表"></a>

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode {
    prev := (*ListNode)(nil)
    cur := head
    for cur != nil {
        head = head.Next
        cur.Next = prev
        prev = cur
        cur = head
    }
    return prev
}
```

---

### 2️⃣ 两两交换链表中的节点<a id="两两交换链表中的节点"></a>

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func swapPairs(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    prevHead := &ListNode{0, head}
    cur, swapNode := head, head.Next
    rt := swapNode
    for {
        prevHead.Next = swapNode
        cur.Next = swapNode.Next
        swapNode.Next = cur
        prevHead = cur
        if cur.Next != nil && cur.Next.Next != nil {
            cur = cur.Next
            swapNode = cur.Next
        }else {
            break
        }
    }
    return rt
}
```

---
### 3️⃣ 环形链表<a id="环形链表"></a>

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func hasCycle(head *ListNode) bool {
    // fast, slow := head, head
    // for slow != nil && fast != nil && fast.Next != nil {
    //     slow = slow.Next
    //     fast = fast.Next.Next
    //     if slow == fast {
    //         return true
    //     }
    // }
    // return false

    m := map[*ListNode]struct{}{}
    cur := head
    for cur != nil {
        if _, ok := m[cur]; ok {
            return true
        }else {
            m[cur] = struct{}{}
        }
        cur = cur.Next
    }
    return false
}
```

---
### 4️⃣ 环形链表-找入环点<a id="环形链表-找入环点"></a>

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func detectCycle(head *ListNode) *ListNode {
    // m := map[*ListNode]struct{}{}
    // for head != nil {
    //     if _, ok := m[head]; ok {
    //         return head
    //     }
    //     m[head] = struct{}{}
    //     head = head.Next
    // }
    // return nil

    fast, slow := head, head
    for fast != nil && fast.Next != nil{
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            fast = head
            for slow != fast {
                fast = fast.Next
                slow = slow.Next
            }
            return slow
        }
    }
    return nil
}
```

---
### 5️⃣ K个一组翻转链表<a id="K个一组翻转链表"></a>

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseKGroup(head *ListNode, k int) *ListNode {
    if head == nil || head.Next == nil || k == 1 {
        return head
    }
    dummy := &ListNode{0, head}
    prevGroup := dummy
    for head != nil {
        curr := head
        count := 0
        for curr != nil && count < k {
            count++
            curr = curr.Next
        }
        if count < k {
            break
        }
        curr = head
        var prev *ListNode
        for i := 0; i < k; i++ {
            next := curr.Next
            curr.Next = prev
            prev = curr
            curr = next
        }
        prevGroup.Next = prev
        head.Next = curr
        prevGroup = head
        head = curr
    }
    return dummy.Next
}
```

---

### 1️⃣ 有效的括号

```go
func isValid(s string) bool {
    stack := []rune{}
    for _, ch := range s{
        switch ch {
        case '(', '{', '[':
            stack = append(stack, ch)
        case ')', '}', ']':
            if len(stack) > 0 {
                if (ch == ')' && stack[len(stack)-1] == '(') ||
                (ch == '}' && stack[len(stack)-1] == '{') ||
                (ch == ']' && stack[len(stack)-1] == '[') {
                    stack = stack[:len(stack)-1]
                }else {
                    return false
                }
            }else {
                return false
            }
        }
    }
    return len(stack) == 0
}
```

---
### 2️⃣ 用栈实现队列

```go
type MyQueue struct {
    stack1 []int
    stack2 []int
}


func Constructor() MyQueue {
    return MyQueue{}
}


func (this *MyQueue) Push(x int)  {
    for len(this.stack2) > 0 {
        this.stack1 = append(this.stack1, this.stack2[len(this.stack2)-1])
        this.stack2 = this.stack2[:len(this.stack2)-1]
    }
    this.stack1 = append(this.stack1, x)
}


func (this *MyQueue) Pop() int {
    if len(this.stack2) > 0 {
        res := this.stack2[len(this.stack2)-1]
        this.stack2 = this.stack2[:len(this.stack2)-1]
        return res
    }
    for len(this.stack1) > 0 {
        this.stack2 = append(this.stack2, this.stack1[len(this.stack1)-1])
        this.stack1 = this.stack1[:len(this.stack1)-1]
    }
    res := this.stack2[len(this.stack2)-1]
    this.stack2 = this.stack2[:len(this.stack2)-1]
    return res
}


func (this *MyQueue) Peek() int {
    if len(this.stack2) > 0 {
        return this.stack2[len(this.stack2)-1]
    }
    for len(this.stack1) > 0 {
        this.stack2 = append(this.stack2, this.stack1[len(this.stack1)-1])
        this.stack1 = this.stack1[:len(this.stack1)-1]
    }
    return this.stack2[len(this.stack2)-1]
}


func (this *MyQueue) Empty() bool {
    return len(this.stack1) == 0 && len(this.stack2) == 0
}


/**
 * Your MyQueue object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(x);
 * param_2 := obj.Pop();
 * param_3 := obj.Peek();
 * param_4 := obj.Empty();
 */
```

---
### 3️⃣ 用队列实现栈

```go
type MyStack struct {
    queue1 []int
    queue2 []int
}


func Constructor() MyStack {
    return MyStack{}
}


func (this *MyStack) Push(x int)  {
    if len(this.queue2) > 0 {
        this.queue2 = append(this.queue2, x)
        return
    }
    this.queue1 = append(this.queue1, x)
}


func (this *MyStack) Pop() int {
    res := 0
    if len(this.queue1) > 0 {
        for len(this.queue1) > 1 {
            this.queue2 = append(this.queue2, this.queue1[0])
            this.queue1 = this.queue1[1:]
        }
        res = this.queue1[0]
        this.queue1 = this.queue1[0:0]
    } else {
        for len(this.queue2) > 1 {
            this.queue1 = append(this.queue1, this.queue2[0])
            this.queue2 = this.queue2[1:]
        }
        res = this.queue2[0]
        this.queue2 = this.queue2[0:0]
    }
    return res
}


func (this *MyStack) Top() int {
    res := 0
    if len(this.queue1) > 0 {
        for len(this.queue1) > 1 {
            this.queue2 = append(this.queue2, this.queue1[0])
            this.queue1 = this.queue1[1:]
        }
        res = this.queue1[0]
        this.queue1 = this.queue1[0:0]
        this.queue2 =  append(this.queue2, res)
    } else {
        for len(this.queue2) > 1 {
            this.queue1 = append(this.queue1, this.queue2[0])
            this.queue2 = this.queue2[1:]
        }
        res = this.queue2[0]
        this.queue2 = this.queue2[0:0]
        this.queue1 =  append(this.queue1, res)
    }
    return res
}


func (this *MyStack) Empty() bool {
    return len(this.queue1) == 0 && len(this.queue2) == 0
}


/**
 * Your MyStack object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(x);
 * param_2 := obj.Pop();
 * param_3 := obj.Top();
 * param_4 := obj.Empty();
 */
```

---

### 1️⃣ 数据流中的第K大元素

```go
type KthLargest struct {
    u sort.IntSlice
    k int
}


func Constructor(k int, nums []int) KthLargest {
    kl := KthLargest{
        u: sort.IntSlice(nums),
        k: k,
    }
    sort.Sort(sort.Reverse(kl.u))
    return kl
}


func (this *KthLargest) Add(val int) int {
    if len(this.u) >= this.k && this.u[this.k-1] >= val {
        return this.u[this.k-1]
    }
    this.u = append(this.u, val)
    sort.Sort(sort.Reverse(this.u))
    this.u = this.u[:this.k]
    return this.u[this.k-1]
}


/**
 * Your KthLargest object will be instantiated and called as such:
 * obj := Constructor(k, nums);
 * param_1 := obj.Add(val);
 */
```

---
### 2️⃣ 滑动窗口最大值

```go
func maxSlidingWindow(nums []int, k int) []int {
    if len(nums) == 0 || k <= 0 || k > len(nums) {
        return []int{}
    }
    if k == 1 {
        return nums
    }
    
    // 使用双端队列存储索引
    deque := make([]int, 0, k)
    // 预分配结果切片容量
    res := make([]int, 0, len(nums)-k+1)
    
    for i := 0; i < len(nums); i++ {
        // 移除窗口外的索引
        if len(deque) > 0 && deque[0] <= i-k {
            deque = deque[1:]
        }
        // 移除队列尾部小于当前元素的索引，保持单调递减
        for len(deque) > 0 && nums[deque[len(deque)-1]] < nums[i] {
            deque = deque[:len(deque)-1]
        }
        // 添加当前索引
        deque = append(deque, i)
        // 窗口形成后记录最大值
        if i >= k-1 {
            res = append(res, nums[deque[0]])
        }
    }
    return res
}
```

---
### 3️⃣ 早餐组合

```go
func breakfastNumber(staple []int, drinks []int, x int) int {
    num := 0
    sort.Ints(staple)
    sort.Ints(drinks)
    for _, s := range staple {
        target := x - s 
        low := 0
        high := len(drinks)-1
        for low <= high {
            mid := (low + high) / 2
            if drinks[mid] > target {
                high = mid - 1
            }else {
                low = mid + 1
            }
        }
        num += low
    }
    return num % 1000000007
}
```

---

### 1️⃣ 相同的树

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func isSameTree(p *TreeNode, q *TreeNode) bool {
    if p == nil && q == nil{return true}
    if (p == nil && q != nil) || (p != nil && q == nil) || p.Val != q.Val {return false}
    if p.Val == q.Val {
        return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)
    }
    return false
}
```

---

### 1️⃣ 有效的字母异位词

```go
func isAnagram(s string, t string) bool {
    if len(s) != len(t) {return false}
    u := map[rune]int{}
    for i := 0; i < len(s); i++ {
        if _, ok := u[rune(s[i])]; ok {
            u[rune(s[i])]++
        } else {
            u[rune(s[i])] = 1
        }
        if _, ok := u[rune(t[i])]; ok {
            u[rune(t[i])]--
        } else {
            u[rune(t[i])] = -1
        }
    }
    for _, v := range u {
        if v != 0 {return false}
    }
    return true
}
```

---
